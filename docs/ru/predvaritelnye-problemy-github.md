# Предзаполненные GitHub Issues — Действия Карты Реальности
**Как использовать:** Скопируйте каждый раздел ниже и вставьте в новую GitHub Issue.

---
## Issue A1: Завершить Реализацию Причинного Анализа GraphSAGE

**Метки:** `reality-map`, `priority:critical`, `component:gnn-routing`

### ID Действия
A1

### Компонент
GNN Маршрутизация / Предсказательное Восстановление

### Цель
Реализовать модуль причинного GraphSAGE для включения предсказательного восстановления, сокращения MTTR с оценочных 5–10с до целевого <3с, и достижения базовой точности ≥85%.

### Критерии Успеха
- Среднее время MTTR в тестовом сценарии <3с (измеряется через `benchmarks/mttr_simulation.py`)
- Опубликована базовая линия точности (набор данных + скрипт оценки)
- Добавлен модуль: `mesh_networking/graphsage_causal.py` или интегрирован в существующий оптимизатор
- Проходят юнит-тесты: `tests/test_graphsage_causal.py`
- Обновлена документация: диаграмма архитектуры + справочник API

### Область Действия
**Включено:**
- Проектирование схемы графа причинных признаков
- Реализация прямого прохода с взвешиванием рёбер через внимание
- Интеграция с конвейером извлечения признаков телеметрии
- Тестовая среда оценки с синтетическими + реальными данными телеметрии

**Исключено:**
- Интеграция федеративного обучения (отложено до B2)
- Потоковый вывод в реальном времени (Фаза 2)

### Шаги Реализации
1. Спроектировать схему графа причинных признаков (узел = mesh-устройство, ребро = путь маршрутизации + метрики задержки/потерь)
2. Реализовать прямой проход GraphSAGE с механизмом внимания для взвешивания рёбер
3. Добавить путь вывода: телеметрия → извлечение признаков → предсказание GraphSAGE → решение маршрутизации
4. Создать скрипт оценки: `benchmarks/gnn_accuracy.py` с базовым набором данных
5. Добавить юнит + интеграционные тесты
6. Обновить `docs/architecture/gnn-routing.md` с обоснованием проекта

### Зависимости / Блокеры
- Конвейер извлечения признаков телеметрии должен быть стабилен (проверить `mesh_networking/telemetry/`)
- Подготовка набора данных v2 (100+ сценариев отказа узлов; координация с Data Eng)
- Решение о библиотеке PyTorch Geometric или DGL

### Оценка Рисков
| Риск | Влияние | Смягчение |
|------|---------|-----------|
| Разреженность данных снижает точность | Высокое | Использовать синтетическую аугментацию + трансферное обучение из схожих наборов топологий |
| Сложность интеграции с существующим mesh-маршрутизатором | Среднее | Флаг функции `USE_GNN_ROUTING=1` для постепенного развёртывания |
| Накладные расходы производительности при выводе | Среднее | Профилировать с `cProfile`; оптимизировать пакетный вывод при необходимости |

### Ответственный и Роли Поддержки
- **Основной Ответственный:** @ml-lead
- **Поддержка:** @mesh-maintainer, @data-engineer, @performance-lead

### График
- **Старт:** 2025-11-10
- **Целевое Завершение:** 2025-12-08 (4 недели)
- **Окно Ревью:** 2025-12-09–2025-12-11

### Чек-лист Результатов
- [ ] Код слит в главную ветку
- [ ] Тесты проходят (юнит: `test_graphsage_causal.py`, интеграция: `test_mesh_routing_with_gnn.py`)
- [ ] Добавлены бенчмарки: `benchmarks/mttr_simulation.py`, `benchmarks/gnn_accuracy.py`
- [ ] Обновлена документация: `docs/architecture/gnn-routing.md`, справочник API
- [ ] Обновлена Reality Map: Компонент #2 готовность → 60%+

### План Верификации
**Выполнение скриптов:**
```bash
python benchmarks/mttr_simulation.py --nodes 100 --fail-rate 0.15 --gnn-enabled
# Ожидается: среднее MTTR <3с, P95 <5с

python benchmarks/gnn_accuracy.py --model graphsage_causal --dataset telemetry_v2
# Ожидается: Точность ≥85% на отложенном тестовом наборе
```

**Критерии приёмки:** Оба скрипта проходят + CI зелёный.

### План Отката / Запасной Вариант
- Отключить GraphSAGE через переменную окружения: `USE_GNN_ROUTING=0`
- Вернуться к базовой mesh-маршрутизации (существующий проверенный путь)
- Если точность <70% после 2 недель, перейти на более простую эвристическую модель

### Примечания После Завершения
_(Заполнить после слияния)_
- Использованный размер набора данных:
- Достигнутая итоговая точность:
- Наблюдаемое улучшение MTTR:
- Извлечённые уроки:

---
## Issue A3: Реализовать Инжектор Шума Дифференциальной Приватности

**Метки:** `reality-map`, `priority:critical`, `component:privacy`

### ID Действия
A3

### Компонент
Приватность / Дифференциальная Приватность

### Цель
Реализовать модуль инжекции шума дифференциальной приватности (DP) для защиты телеметрии и данных градиентов от утечки приватности, достигая измеримой гарантии ε-приватности.

### Критерии Успеха
- Модуль инжектора шума: `privacy/dp_noise.py` с механизмами Лапласа и Гаусса
- Тест утечки приватности: `tests/test_dp_leakage.py` проверяет ε < 1.0 для агрегации телеметрии
- Интеграция с конвейером телеметрии: публикуются зашумлённые метрики вместо сырых значений
- Документация: руководство по настройке параметров DP + отслеживание бюджета приватности

### Область Действия
**Включено:**
- Механизм Лапласа (для запросов count/sum)
- Механизм Гаусса (для агрегации градиентов в будущей работе FL)
- Трекер бюджета приватности (накопление ε по запросам)
- Вспомогательные функции анализа чувствительности

**Исключено:**
- Гомоморфное шифрование (отдельное действие, приоритет C)
- Продвинутые теоремы композиции (Фаза 2)

### Шаги Реализации
1. Создать `privacy/dp_noise.py` с функциями `add_laplace_noise()` и `add_gaussian_noise()`
2. Реализовать трекер бюджета приватности: класс `PrivacyBudgetTracker`
3. Интегрировать с агрегацией телеметрии: обернуть вызовы публикации метрик
4. Добавить анализ чувствительности: `calculate_sensitivity()` для распространённых типов запросов
5. Создать валидационный тест: симулировать атаку адверсарной реконструкции, проверить границу ε
6. Документировать руководство по выбору параметров: ε, δ, чувствительность для разных случаев использования

### Зависимости / Блокеры
- Идентифицированы точки агрегации телеметрии (координация с Observability Lead)
- Ревью политики приватности (юридическое/соответствие подписывает порог ε=1.0)

### Оценка Рисков
| Риск | Влияние | Смягчение |
|------|---------|-----------|
| Слишком высокий шум → потеря полезности | Среднее | Адаптивная настройка ε на основе важности запроса |
| Слишком низкий шум → нарушение приватности | Высокое | Консервативный ε=0.5 по умолчанию, требуется явное переопределение |
| Исчерпание бюджета приватности | Среднее | Реализовать расписание сброса бюджета (ежедневно/еженедельно) |

### Ответственный и Роли Поддержки
- **Основной Ответственный:** @privacy-lead
- **Поддержка:** @data-engineer, @security-lead, @compliance

### График
- **Старт:** 2025-11-10
- **Целевое Завершение:** 2025-12-08 (4 недели)
- **Окно Ревью:** 2025-12-09–2025-12-11

### Чек-лист Результатов
- [ ] Код модуля: `privacy/dp_noise.py`
- [ ] Тесты: `tests/test_dp_leakage.py`, `tests/test_privacy_budget.py`
- [ ] Интеграция: Вызовы публикации телеметрии обёрнуты DP
- [ ] Документация: `docs/privacy/differential-privacy.md`, руководство по выбору параметров
- [ ] Обновлена Reality Map: Компонент #9 готовность → 60%+

### План Верификации
**Выполнение скриптов:**
```bash
python tests/test_dp_leakage.py --epsilon 1.0 --delta 1e-5 --n-queries 100
# Ожидается: Измеренный ε_эмпирический ≤ 1.1 (с композицией)

python examples/telemetry_dp_demo.py --publish-interval 10s
# Ожидается: Опубликованные метрики имеют добавленный шум; исходные значения не восстановимы
```

### План Отката / Запасной Вариант
- Флаг функции: `ENABLE_DP=0` для публикации сырых метрик (только разработка)
- Если бюджет приватности исчерпан, ставить метрики в очередь до сброса
- Откат только к агрегации (без DP) с логами предупреждений

### Примечания После Завершения
_(Заполнить после слияния)_
- Выбранное значение ε:
- Измеренное влияние на полезность:
- Проверенная гарантия приватности:
- Извлечённые уроки:

---
## Issue A4: Заменить PQC-макеты на Реальные Примитивы

**Метки:** `reality-map`, `priority:critical`, `component:pqc-crypto`

### ID Действия
A4

### Компонент
Постквантовая Криптография (PQC)

### Цель
Заменить mock/stub PQC-реализации на реальные криптографические примитивы (Kyber, Dilithium, Falcon) используя `liboqs` или эквивалент, включая production-ready квантово-устойчивую безопасность.

### Критерии Успеха
- Реальная генерация ключей, подпись, верификация для Kyber-768, Dilithium-3, Falcon-512
- Проходят интеграционные тесты: `tests/test_pqc_mesh_integration.py` (без макетов)
- Бенчмарк производительности: генерация ключей + подпись/верификация <5мс задержка P95
- Документация: обоснование выбора алгоритма + руководство по использованию API
- **ИЛИ** если реальная реализация отложена: Пометить компонент как "Экспериментальный PoC" во всех документах

### Область Действия
**Включено:**
- Интегрировать библиотеку `liboqs-python` или `pqcrypto`
- Заменить mock-функции в `crypto/pqc.py`
- Обновить mesh-handshake для использования реального обмена ключами Kyber
- Обновить верификацию подписи в применении политики

**Исключено:**
- Гибридные классические+PQ схемы (Фаза 2)
- Собственная реализация PQC (использовать только проверенные библиотеки)

### Шаги Реализации
1. **Точка решения:** liboqs-python vs. pqcrypto vs. пометить как PoC
2. Если продолжаем: Установить и протестировать `liboqs-python` в CI-окружении
3. Заменить mock генерацию ключей: `generate_kyber_keypair()`, `generate_dilithium_keypair()`
4. Заменить mock подпись: `dilithium_sign()`, `falcon_sign()`
5. Обновить интеграцию mesh handshake: реальный обмен ключами в `mesh_networking/handshake.py`
6. Бенчмарк производительности: добавить `benchmarks/pqc_performance.py`
7. Обновить документацию: пометить статус, добавить соображения безопасности

### Зависимости / Блокеры
- Стабильность библиотеки `liboqs` на целевых платформах (Linux, macOS)
- Поддержка CI-окружения сборки для скомпилированных крипто-библиотек
- Юридическое/соответствие ревью выбора алгоритмов (особенно экспортные ограничения)

### Оценка Рисков
| Риск | Влияние | Смягчение |
|------|---------|-----------|
| Сбои сборки liboqs на CI | Высокое | Закрепить конкретный коммит, добавить откат к режиму PoC |
| Регрессия производительности (задержка >10мс) | Среднее | Профилировать и оптимизировать; рассмотреть понижение алгоритма (например, Kyber-512) |
| Устаревание алгоритма (обновления NIST) | Низкое | Отслеживать объявления NIST; проектировать для заменяемых примитивов |

### Ответственный и Роли Поддержки
- **Основной Ответственный:** @crypto-lead
- **Поддержка:** @devsecops, @mesh-maintainer, @external-auditor (Фаза 2)

### График
- **Старт:** 2025-11-10
- **Целевое Завершение:** 2025-12-01 (3 недели)
- **Окно Ревью:** 2025-12-02–2025-12-04
- **Дедлайн Решения:** 2025-11-13 (реализовать реальное vs. пометить PoC)

### Чек-лист Результатов
- [ ] Задокументировано решение: Реализовать реальные примитивы ИЛИ пометить PoC
- [ ] Если реальное: Код слит с интеграцией `liboqs-python`
- [ ] Если реальное: Тесты проходят без макетов
- [ ] Если реальное: Добавлены бенчмарки: `benchmarks/pqc_performance.py`
- [ ] Если PoC: Все документы обновлены с предупреждениями "Экспериментально - Не для Production"
- [ ] Обновлена Reality Map: Компонент #5 готовность → 75% (реальное) или 40% (помечен PoC)

### План Верификации
**Если реальная реализация:**
```bash
python benchmarks/pqc_performance.py --algorithm kyber768 --iterations 1000
# Ожидается: P95 задержка <5мс для keygen+encaps+decaps

python tests/test_pqc_mesh_integration.py --no-mocks
# Ожидается: Все тесты проходят с реальными крипто-операциями
```

**Если помечен PoC:**
- Проверить появление логов предупреждений в mesh handshake: "Используется экспериментальный PQC - не production-ready"
- Обновить `README.md`, `docs/security.md` с дисклеймером PoC

### План Отката / Запасной Вариант
- Флаг функции: `USE_REAL_PQC=0` для возврата к макетам (только тестирование)
- Если реальная реализация нестабильна, вернуться к классической крипто с обновлением дорожной карты
- Плавная деградация: handshake откатывается на ECDH если PQC недоступен

### Примечания После Завершения
_(Заполнить после слияния)_
- Выбранная библиотека:
- Развёрнутые алгоритмы:
- Измеренная производительность:
- Статус готовности к production:
- Извлечённые уроки:

---
## Дополнительные Issues (B1–B5, C1–C5) — Высокий/Средний Приоритет

Для краткости, B1–B5 и C1–C5 следуют той же структуре шаблона. Ключевые детали:

**B1 — Реализация Программ Наблюдаемости eBPF:**
- Ответственный: @systems-engineer
- Цель: 2 программы eBPF (потеря пакетов XDP, задержка системного вызова kprobe) + накладные расходы CI <5%
- График: 4–6 недель

**B2 — Оркестратор Федеративного Обучения:**
- Ответственный: @ml-lead
- Цель: FedAvg агрегация, тест сходимости на 10–50 узлах, точность 85%+
- График: 6–8 недель

**B3 — Модуль Квадратичного Голосования:**
- Ответственный: @dao-dev
- Цель: Вычисление sqrt(token) весов, интеграция с Snapshot
- График: 3–4 недели

**B4 — Верификация HNSW-оптимизации в RAG:**
- Ответственный: @ml-lead
- Цель: Подтвердить использование hnswlib или задокументировать альтернативу, бенчмарк 95% полноты <25мс
- График: 2–3 недели

**B5 — Сквозной Тест Политики Zero Trust:**
- Ответственный: @security-lead
- Цель: Демонстрация блокировки неавторизованного узла, проверка SVID в mesh-маршрутизации
- График: 2–3 недели

**C1 — Внешний Криптографический Аудит:**
- Ответственный: @crypto-lead
- Цель: Привлечь NCC Group или эквивалент для аудита PQC
- График: 2–3 месяца после завершения A4

**C2 — Воспроизводимые Бенчмарки Производительности:**
- Ответственный: @performance-lead
- Цель: `benchmark_models.py` + RESULTS.md со спецификациями оборудования
- График: 2–3 недели

**C3 — Подпись Артефактов Sigstore/Cosign:**
- Ответственный: @devops
- Цель: CI-конвейер генерирует + проверяет подписанные артефакты
- График: 3–4 недели

**C4 — CI для Доступности (axe/pa11y):**
- Ответственный: @ux-lead
- Цель: Автоматизированное сканирование WCAG в CI, целевая базовая линия ≥97%
- График: 4–6 недель

**C5 — Ежемесячные Обновления Reality Map:**
- Ответственный: @tech-writer
- Цель: Ongoing ежемесячные обновления версий + синхронизация changelog
- График: Непрерывно (начиная после слияния A5)

---
**Всего Issues:** 13 (A1, A3–A5, B1–B5, C1–C5)

**Использование:** Скопируйте каждый раздел выше в новую GitHub Issue. Настройте никнеймы ответственных и даты по необходимости.
